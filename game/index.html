<!DOCTYPE html>
<html>
<head>
    <title>Advanced 3D Web Gun Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .hud {
            position: absolute;
            left: 20px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        #ammo-display { bottom: 20px; font-size: 30px; color: #ffeb3b; }
        #health-display { bottom: 60px; font-size: 30px; color: #ff3b3b; }
        #prompt-display {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            display: none;
        }
        #loading {
            position: absolute; top: 10px; right: 10px;
            color: yellow; font-family: monospace;
        }
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: red;
            font-family: sans-serif;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Assets...</div>
    <div id="ammo-display" class="hud">Ammo: 30</div>
    <div id="health-display" class="hud">Health: 100</div>
    <div id="prompt-display" class="hud">Press 'E' to enter Tank</div>
    <div id="game-over">
        <h1 style="font-size: 80px; margin: 0;">GAME OVER</h1>
        <h3 style="color: white;">Refresh to Restart</h3>
    </div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OBJLoader -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            gravity: 0.02,
            jumpForce: 0.35,
            speed: 0.15,
            sprintSpeed: 0.25,
            playerHeight: 2.5,
            pillarCount: 30
        };

        // --- GLOBALS ---
        let scene, camera, renderer, player, gun, tank, tankTurret;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let pillars = [];
        let colliders = []; // Everything the player can step on
        let ammo = 30;
        let health = 100;
        let isGameOver = false;
        let isInTank = false;
        
        // Inputs
        const keys = {};
        let canJump = false;
        let playerVelocityY = 0;
        let isRecoiling = false;
        let recoilTime = 0;

        // Assets
        const textures = {};
        const sounds = {};
        let enemyModel = null;

        // UI
        const ui = {
            ammo: document.getElementById('ammo-display'),
            health: document.getElementById('health-display'),
            prompt: document.getElementById('prompt-display'),
            gameOver: document.getElementById('game-over'),
            loading: document.getElementById('loading')
        };

        init();
        loadAssets(); // Try to load assets in background
        animate();

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Default Sky Blue
            scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 2. Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // 3. Ground
            // Fallback Green color if texture fails
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 }); 
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);
            colliders.push(ground);

            // 4. Pillars (Brown things)
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            for(let i=0; i<CONFIG.pillarCount; i++) {
                const h = Math.random() * 8 + 4;
                const geo = new THREE.CylinderGeometry(2, 2, h, 8);
                const pillar = new THREE.Mesh(geo, pillarMat);
                pillar.position.set(
                    Math.random() * 160 - 80,
                    h / 2,
                    Math.random() * 160 - 80
                );
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                pillar.name = "pillar";
                // Add a flat top for collision
                pillar.userData = { height: h, radius: 2 };
                scene.add(pillar);
                pillars.push(pillar);
                colliders.push(pillar);
            }

            // 5. Player Rig
            player = new THREE.Group();
            player.position.set(0, 10, 0); // Start high
            scene.add(player);
            player.add(camera);

            // 6. Gun
            const gunGeo = new THREE.BoxGeometry(0.15, 0.25, 0.8);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0.4, -0.4, -0.8);
            camera.add(gun);

            // 7. Tank
            createTank();

            // 8. Enemies
            spawnEnemies();

            // 9. Events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('mousedown', () => {
                if(document.pointerLockElement !== document.body) document.body.requestPointerLock();
                else shoot();
            });
            document.addEventListener('mousemove', (e) => {
                if(document.pointerLockElement === document.body && !isGameOver) {
                    if(isInTank) {
                        tank.rotation.y -= e.movementX * 0.002;
                    } else {
                        player.rotation.y -= e.movementX * 0.002;
                        camera.rotation.x -= e.movementY * 0.002;
                        camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                    }
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createTank() {
            const tankMat = new THREE.MeshStandardMaterial({ color: 0x4b5320 }); // Army Green
            tank = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(5, 2.5, 8), tankMat);
            body.position.y = 1.25;
            body.castShadow = true;
            tank.add(body);

            tankTurret = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 4), tankMat);
            tankTurret.position.y = 3.5;
            tankTurret.castShadow = true;
            tank.add(tankTurret);
            
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 5), new THREE.MeshStandardMaterial({color: 0x222222}));
            barrel.rotation.x = Math.PI/2;
            barrel.position.set(0, 0, 3);
            tankTurret.add(barrel);

            tank.position.set(20, 0, -20);
            scene.add(tank);
            colliders.push(body); // Can stand on tank
        }

        function spawnEnemies() {
            const dummyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const dummyGeo = new THREE.CapsuleGeometry(0.8, 2, 4);
            
            for(let i=0; i<10; i++) {
                const enemy = new THREE.Mesh(dummyGeo, dummyMat);
                enemy.position.set(Math.random()*100-50, 2, Math.random()*100-50);
                enemy.userData = { 
                    health: 3, 
                    shootTimer: Math.random() * 3,
                    isEnemy: true 
                };
                scene.add(enemy);
                enemies.push(enemy);
            }
        }

        function loadAssets() {
            const texLoader = new THREE.TextureLoader();
            const audLoader = new THREE.AudioLoader();
            const objLoader = new THREE.OBJLoader();
            const listener = new THREE.AudioListener();
            camera.add(listener);

            const loadTex = (name, file) => {
                texLoader.load('assets/' + file, (tex) => {
                    textures[name] = tex;
                    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                    // Update materials if they exist
                    if(name === 'grass') scene.children.find(c => c.name === 'ground').material.map = tex;
                    if(name === 'brown') pillars.forEach(p => p.material.map = tex);
                    if(name === 'tank') tank.children.forEach(c => c.material.map = tex);
                    if(name === 'sky') {
                         const skyGeo = new THREE.SphereGeometry(500, 60, 40);
                         skyGeo.scale(-1, 1, 1);
                         const skyMat = new THREE.MeshBasicMaterial({ map: tex });
                         scene.add(new THREE.Mesh(skyGeo, skyMat));
                         scene.background = null; // Remove solid color
                    }
                    if(name === 'gun') gun.material.map = tex;
                    ui.loading.style.display = 'none';
                }, undefined, (err) => console.log("Texture missing: " + file));
            };

            // Try loading textures (game works even if these fail)
            loadTex('grass', 'grass.png');
            loadTex('brown', 'brown.png');
            loadTex('sky', 'sky.png');
            loadTex('gun', 'gun.png');
            loadTex('tank', 'tank.png');
            loadTex('bullet', 'bullet.png');
            loadTex('enemy', 'enemy.png');

            // Try loading Audio
            const loadSound = (name, file) => {
                audLoader.load('assets/' + file, (buffer) => {
                    const s = new THREE.Audio(listener);
                    s.setBuffer(buffer);
                    sounds[name] = s;
                }, undefined, () => {});
            };
            loadSound('jump', 'jump.mp3');
            loadSound('shoot', 'gun.mp3');
            loadSound('enemyShoot', 'enemygun.mp3');
            loadSound('landGrass', 'fallinggrass.mp3');
            loadSound('landMetal', 'fallingonmetal.mp3');

            // Try loading OBJ
            objLoader.load('assets/enemy.obj', (obj) => {
                enemyModel = obj;
                // Replace current dummy enemies with models
                enemies.forEach(e => {
                    const pos = e.position.clone();
                    scene.remove(e);
                    const newEnemy = obj.clone();
                    newEnemy.position.copy(pos);
                    // Apply texture if loaded, else red
                    const mat = new THREE.MeshStandardMaterial({ 
                        map: textures.enemy || null, 
                        color: textures.enemy ? 0xffffff : 0xff0000 
                    });
                    newEnemy.traverse(c => { if(c.isMesh) { c.material = mat; c.castShadow = true; } });
                    newEnemy.userData = e.userData;
                    newEnemy.scale.set(0.8, 0.8, 0.8);
                    scene.add(newEnemy);
                    // update the array reference needs careful handling, for now we just rebuild
                });
                // Re-populate enemies array (simplified)
                enemies = scene.children.filter(c => c.userData && c.userData.isEnemy);
            }, undefined, () => console.log("OBJ missing"));
        }

        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'e') toggleTank();
            if(e.code === 'Space' && canJump) {
                playerVelocityY = CONFIG.jumpForce;
                canJump = false;
                if(sounds.jump) sounds.jump.play();
            }
        }

        function toggleTank() {
            if(isInTank) {
                // Exit
                isInTank = false;
                gun.visible = true;
                player.visible = true;
                player.position.copy(tank.position).add(new THREE.Vector3(5, 5, 0));
            } else {
                // Enter if close
                if(player.position.distanceTo(tank.position) < 8) {
                    isInTank = true;
                    gun.visible = false;
                    player.visible = false;
                }
            }
        }

        function shoot() {
            if(ammo <= 0 && !isInTank) return;

            if(!isInTank) {
                ammo--;
                ui.ammo.textContent = "Ammo: " + ammo;
                if(sounds.shoot) { sounds.shoot.isPlaying = false; sounds.shoot.play(); }
                
                // Recoil anim
                isRecoiling = true; 
                recoilTime = 0;

                const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0xffff00, map: textures.bullet}));
                b.position.copy(player.position);
                camera.getWorldDirection(b.velocity = new THREE.Vector3()).multiplyScalar(3);
                bullets.push(b);
                scene.add(b);
            } else {
                // Tank shoot
                 if(sounds.shoot) sounds.shoot.play(); // Reuse sound for now
                 const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 0x000000}));
                 b.position.copy(tankTurret.getWorldPosition(new THREE.Vector3())).add(new THREE.Vector3(0,0,4).applyQuaternion(tank.quaternion));
                 tank.getWorldDirection(b.velocity = new THREE.Vector3()).multiplyScalar(2);
                 // Adjust for turret rotation not implemented fully, just shooting forward of tank for stability
                 bullets.push(b);
                 scene.add(b);
            }
        }

        function updatePlayerPhysics() {
            if(isInTank) return;

            const speed = keys['shift'] ? CONFIG.sprintSpeed : CONFIG.speed;
            const dir = new THREE.Vector3();
            if(keys['w']) dir.z -= 1;
            if(keys['s']) dir.z += 1;
            if(keys['a']) dir.x -= 1;
            if(keys['d']) dir.x += 1;

            // Direction relative to camera
            dir.applyEuler(new THREE.Euler(0, player.rotation.y, 0)).normalize().multiplyScalar(speed);

            // Horizontal Collision (Simplified: Check future position)
            const nextPos = player.position.clone().add(new THREE.Vector3(dir.x, 0, dir.z));
            let collided = false;
            
            // Check Pillars
            for(let p of pillars) {
                const dx = nextPos.x - p.position.x;
                const dz = nextPos.z - p.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if(dist < p.userData.radius + 0.5 && nextPos.y < p.userData.height) {
                    collided = true; 
                    break;
                }
            }
            if(!collided) {
                player.position.x += dir.x;
                player.position.z += dir.z;
            }

            // Vertical Physics
            playerVelocityY -= CONFIG.gravity;
            player.position.y += playerVelocityY;

            // Ground Collision
            canJump = false;
            
            // Check Floor
            if(player.position.y < CONFIG.playerHeight) {
                player.position.y = CONFIG.playerHeight;
                playerVelocityY = 0;
                if(!canJump && Math.abs(playerVelocityY) > 0.1 && sounds.landGrass) sounds.landGrass.play();
                canJump = true;
            }

            // Check Pillar Tops
            for(let p of pillars) {
                const dx = player.position.x - p.position.x;
                const dz = player.position.z - p.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if(dist < p.userData.radius && player.position.y < p.userData.height + CONFIG.playerHeight && player.position.y > p.userData.height) {
                    player.position.y = p.userData.height + CONFIG.playerHeight;
                    playerVelocityY = 0;
                    canJump = true;
                    if(sounds.landMetal && !sounds.landMetal.isPlaying) sounds.landMetal.play();
                }
            }
            
            // Infinite fall fix
            if(player.position.y < -50) player.position.set(0, 20, 0);
        }

        function animate() {
            if(isGameOver) return;
            requestAnimationFrame(animate);

            updatePlayerPhysics();

            // Tank Controls
            if(isInTank) {
                if(keys['w']) tank.translateZ(0.2);
                if(keys['s']) tank.translateZ(-0.2);
                if(keys['a']) tank.rotation.y += 0.02;
                if(keys['d']) tank.rotation.y -= 0.02;
                
                // Cam follows tank
                const camOffset = new THREE.Vector3(0, 8, -12);
                camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), tank.rotation.y);
                camera.position.copy(tank.position).add(camOffset);
                camera.lookAt(tank.position);
                ui.prompt.style.display = 'none';
            } else {
                ui.prompt.style.display = player.position.distanceTo(tank.position) < 8 ? 'block' : 'none';
            }

            // Gun Recoil Animation
            if(isRecoiling) {
                recoilTime += 0.1;
                gun.position.z = -0.8 + Math.sin(recoilTime) * 0.2;
                if(recoilTime > Math.PI) {
                    isRecoiling = false;
                    gun.position.z = -0.8;
                }
            } else {
                gun.position.z = THREE.MathUtils.lerp(gun.position.z, -0.8, 0.1);
            }

            // Enemies AI
            enemies.forEach(e => {
                const target = isInTank ? tank.position : player.position;
                e.lookAt(target.x, e.position.y, target.z);
                
                if(e.position.distanceTo(target) > 5) {
                    e.translateZ(0.05);
                }

                // Shoot
                e.userData.shootTimer -= 0.016;
                if(e.userData.shootTimer <= 0) {
                    e.userData.shootTimer = 2 + Math.random();
                    if(sounds.enemyShoot) {
                        const s = sounds.enemyShoot;
                        if(!s.isPlaying) s.play();
                    }
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color:0xff0000}));
                    b.position.copy(e.position).add(new THREE.Vector3(0,1,0));
                    const dir = new THREE.Vector3().subVectors(target, e.position).normalize();
                    b.velocity = dir.multiplyScalar(0.5);
                    enemyBullets.push(b);
                    scene.add(b);
                }
            });

            // Bullets logic
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.position.add(b.velocity);
                
                // Collisions
                let hit = false;
                enemies.forEach((e, ei) => {
                    if(!hit && b.position.distanceTo(e.position) < 1.5) {
                        hit = true;
                        scene.remove(b);
                        bullets.splice(i, 1);
                        
                        // Damage Enemy
                        e.userData.health--;
                        if(e.userData.health <= 0) {
                            scene.remove(e);
                            enemies.splice(ei, 1);
                            // Drop Ammo
                            const drop = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:0x00ff00, map: textures.bullet}));
                            drop.position.copy(e.position);
                            drop.name = "ammo";
                            scene.add(drop);
                        }
                    }
                });
                if(!hit && b.position.length() > 200) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // Enemy Bullets logic
            for(let i=enemyBullets.length-1; i>=0; i--) {
                const b = enemyBullets[i];
                b.position.add(b.velocity);
                
                if(!isInTank && b.position.distanceTo(player.position) < 1.0) {
                    health -= 10;
                    ui.health.textContent = "Health: " + health;
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                    if(health <= 0) {
                        isGameOver = true;
                        ui.gameOver.style.display = 'flex';
                        document.exitPointerLock();
                    }
                } else if(b.position.length() > 200) {
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                }
            }

            // Pickups
            scene.children.forEach(c => {
                if(c.name === "ammo" && player.position.distanceTo(c.position) < 2) {
                    ammo += 10;
                    ui.ammo.textContent = "Ammo: " + ammo;
                    scene.remove(c);
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>