<!DOCTYPE html>
<html>
<head>
    <title>Advanced 3D Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; }
        canvas { display: block; }
        .hud {
            position: absolute;
            left: 20px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 5;
        }
        #ammo-display { bottom: 20px; font-size: 30px; color: #ffeb3b; }
        #health-display { bottom: 60px; font-size: 30px; color: #ff3b3b; }
        #prompt-display {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            display: none;
            text-align: center;
        }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            color: yellow; font-family: monospace;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; z-index: 100;
            transition: opacity 0.5s;
        }
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: red;
            font-family: sans-serif;
            z-index: 10;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">Loading Assets... (Starting in 2s)</div>

    <!-- HUD -->
    <div id="ammo-display" class="hud">Ammo: 30</div>
    <div id="health-display" class="hud">Health: 100</div>
    <div id="prompt-display" class="hud">Press 'E' to enter Tank</div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <h1 style="font-size: 80px; margin: 0;">GAME OVER</h1>
        <h3 style="color: white; cursor: pointer;" onclick="location.reload()">Click here to Restart</h3>
    </div>

    <!-- Three.js & Loaders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>

    <script>
        // --- FORCE START FALLBACK ---
        // This ensures the loading screen goes away even if assets fail
        setTimeout(() => {
            const loader = document.getElementById('loading');
            if(loader) {
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 500);
            }
        }, 1500);

        // --- CONFIGURATION ---
        const CONFIG = {
            gravity: 0.02,
            jumpForce: 0.35,
            speed: 0.15,
            sprintSpeed: 0.25,
            playerHeight: 2.5,
            pillarCount: 30
        };

        // --- GLOBALS ---
        let scene, camera, renderer, player, gun, tank, tankTurret;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let pillars = [];
        let colliders = [];
        let ammo = 30;
        let health = 100;
        let isGameOver = false;
        let isInTank = false;
        
        // Inputs
        const keys = {};
        let canJump = false;
        let playerVelocityY = 0;
        let isRecoiling = false;
        let recoilTime = 0;

        // Assets Containers
        const textures = {};
        const sounds = {};
        let enemyModel = null;

        // UI Refs
        const ui = {
            ammo: document.getElementById('ammo-display'),
            health: document.getElementById('health-display'),
            prompt: document.getElementById('prompt-display'),
            gameOver: document.getElementById('game-over'),
            loading: document.getElementById('loading')
        };

        init();
        animate();

        function init() {
            // 1. Manager Setup (Handles the assets)
            const manager = new THREE.LoadingManager();
            manager.onLoad = function ( ) {
                console.log( 'Loading complete!');
                const l = document.getElementById('loading');
                if(l) { l.style.opacity = 0; setTimeout(()=>l.style.display='none',500); }
            };
            
            // 2. Load Assets (Async)
            loadAssets(manager);

            // 3. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Default Sky
            scene.fog = new THREE.Fog(0x87ceeb, 20, 120);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // 5. Ground (Green Fallback)
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 }); 
            const groundGeo = new THREE.PlaneGeometry(300, 300);
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);
            colliders.push(ground);

            // 6. Pillars
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            for(let i=0; i<CONFIG.pillarCount; i++) {
                const h = Math.random() * 8 + 4;
                const geo = new THREE.CylinderGeometry(2, 2, h, 16);
                const pillar = new THREE.Mesh(geo, pillarMat);
                pillar.position.set(
                    Math.random() * 160 - 80,
                    h / 2,
                    Math.random() * 160 - 80
                );
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                pillar.name = "pillar";
                // Store data for collision
                pillar.userData = { height: h, radius: 2 };
                scene.add(pillar);
                pillars.push(pillar);
                colliders.push(pillar);
            }

            // 7. Player
            player = new THREE.Group();
            player.position.set(0, 10, 0); 
            scene.add(player);
            player.add(camera);

            // 8. Gun
            const gunGeo = new THREE.BoxGeometry(0.15, 0.25, 0.8);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0.4, -0.4, -0.8);
            gun.name = "playerGun";
            camera.add(gun);

            // 9. Tank
            createTank();

            // 10. Enemies (Start with dummies, replace when OBJ loads)
            spawnEnemies();

            // 11. Events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('mousedown', () => {
                if(document.pointerLockElement !== document.body) document.body.requestPointerLock();
                else shoot();
            });
            document.addEventListener('mousemove', (e) => {
                if(document.pointerLockElement === document.body && !isGameOver) {
                    if(isInTank) {
                        tank.rotation.y -= e.movementX * 0.002;
                    } else {
                        player.rotation.y -= e.movementX * 0.002;
                        camera.rotation.x -= e.movementY * 0.002;
                        camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                    }
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadAssets(manager) {
            const texLoader = new THREE.TextureLoader(manager);
            const audLoader = new THREE.AudioLoader(manager);
            const objLoader = new THREE.OBJLoader(manager);
            const audioListener = new THREE.AudioListener();
            camera.add(audioListener);

            // Helper to assign texture if loaded
            const assignTex = (name, path, objectName) => {
                texLoader.load('./assets/' + path, (tex) => {
                    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                    textures[name] = tex;
                    
                    // Auto-apply to known objects
                    if(name === 'grass') scene.children.find(c => c.name === 'ground').material.map = tex;
                    if(name === 'brown') pillars.forEach(p => p.material.map = tex);
                    if(name === 'gun') gun.material.map = tex;
                    if(name === 'tank') {
                        tank.children.forEach(c => c.material.map = tex);
                    }
                    if(name === 'sky') {
                         const skyGeo = new THREE.SphereGeometry(500, 60, 40);
                         skyGeo.scale(-1, 1, 1);
                         const skyMat = new THREE.MeshBasicMaterial({ map: tex });
                         scene.add(new THREE.Mesh(skyGeo, skyMat));
                         scene.background = null;
                    }
                    // Force update materials
                    scene.traverse(c => { if(c.material) c.material.needsUpdate = true; });
                }, undefined, (err) => { console.warn("Texture failed (using color):", path); });
            };

            assignTex('grass', 'grass.png');
            assignTex('brown', 'brown.png');
            assignTex('sky', 'sky.png');
            assignTex('gun', 'gun.png');
            assignTex('tank', 'tank.png');
            assignTex('bullet', 'bullet.png');
            assignTex('enemy', 'enemy.png');

            const loadSound = (name, path) => {
                audLoader.load('./assets/' + path, (buffer) => {
                    const s = new THREE.Audio(audioListener);
                    s.setBuffer(buffer);
                    sounds[name] = s;
                }, undefined, (err) => console.warn("Sound failed:", path));
            };
            loadSound('jump', 'jump.mp3');
            loadSound('shoot', 'gun.mp3');
            loadSound('enemyShoot', 'enemygun.mp3');
            loadSound('landGrass', 'fallinggrass.mp3');
            loadSound('landMetal', 'fallingonmetal.mp3');

            objLoader.load('./assets/enemy.obj', (obj) => {
                enemyModel = obj;
                // Replace dummies
                replaceEnemiesWithModel();
            }, undefined, (err) => console.warn("OBJ failed:", err));
        }

        function createTank() {
            const tankMat = new THREE.MeshStandardMaterial({ color: 0x4b5320 });
            tank = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(5, 2.5, 8), tankMat);
            body.position.y = 1.25;
            body.castShadow = true;
            tank.add(body);

            tankTurret = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 4), tankMat);
            tankTurret.position.y = 3.5;
            tankTurret.castShadow = true;
            tank.add(tankTurret);
            
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 5), new THREE.MeshStandardMaterial({color: 0x222222}));
            barrel.rotation.x = Math.PI/2;
            barrel.position.set(0, 0, 3);
            tankTurret.add(barrel);

            tank.position.set(20, 0, -20);
            scene.add(tank);
            colliders.push(body); 
        }

        function spawnEnemies() {
            // Initial dummies
            const dummyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const dummyGeo = new THREE.CapsuleGeometry(0.8, 2, 4);
            for(let i=0; i<10; i++) {
                const enemy = new THREE.Mesh(dummyGeo, dummyMat);
                initEnemy(enemy);
            }
        }

        function initEnemy(enemy) {
            enemy.position.set(Math.random()*120-60, 2, Math.random()*120-60);
            enemy.userData = { health: 3, shootTimer: Math.random() * 3, isEnemy: true };
            scene.add(enemy);
            enemies.push(enemy);
        }

        function replaceEnemiesWithModel() {
            if(!enemyModel) return;
            const oldEnemies = [...enemies];
            enemies = []; // Clear and rebuild

            oldEnemies.forEach(old => {
                scene.remove(old);
                const newEnemy = enemyModel.clone();
                newEnemy.position.copy(old.position);
                newEnemy.userData = old.userData;
                
                // Apply texture if available
                const mat = new THREE.MeshStandardMaterial({ 
                    map: textures.enemy || null, 
                    color: textures.enemy ? 0xffffff : 0xff0000 
                });
                newEnemy.traverse(c => { if(c.isMesh) { c.material = mat; c.castShadow = true; } });
                
                newEnemy.scale.set(0.8, 0.8, 0.8); // Scale OBJ
                scene.add(newEnemy);
                enemies.push(newEnemy);
            });
        }

        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'e') toggleTank();
            if(e.code === 'Space' && canJump) {
                playerVelocityY = CONFIG.jumpForce;
                canJump = false;
                if(sounds.jump) sounds.jump.play();
            }
        }

        function toggleTank() {
            if(isInTank) {
                isInTank = false;
                gun.visible = true;
                player.visible = true;
                player.position.copy(tank.position).add(new THREE.Vector3(5, 5, 0));
            } else if(player.position.distanceTo(tank.position) < 8) {
                isInTank = true;
                gun.visible = false;
                player.visible = false;
            }
        }

        function shoot() {
            if(ammo <= 0 && !isInTank) return;

            if(!isInTank) {
                ammo--;
                ui.ammo.textContent = "Ammo: " + ammo;
                if(sounds.shoot) { if(sounds.shoot.isPlaying) sounds.shoot.stop(); sounds.shoot.play(); }
                
                isRecoiling = true; recoilTime = 0;
                
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffff00, map: textures.bullet || null}));
                b.position.copy(player.position);
                camera.getWorldDirection(b.velocity = new THREE.Vector3()).multiplyScalar(3);
                bullets.push(b);
                scene.add(b);
            } else {
                // Tank Fire
                if(sounds.shoot) { if(sounds.shoot.isPlaying) sounds.shoot.stop(); sounds.shoot.play(); }
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({color: 0x000000}));
                b.position.copy(tankTurret.getWorldPosition(new THREE.Vector3())).add(new THREE.Vector3(0,0,4).applyQuaternion(tank.rotation));
                tank.getWorldDirection(b.velocity = new THREE.Vector3()).multiplyScalar(2);
                b.isShell = true;
                bullets.push(b);
                scene.add(b);
            }
        }

        function updatePlayerPhysics() {
            if(isInTank) return;

            const speed = keys['shift'] ? CONFIG.sprintSpeed : CONFIG.speed;
            const dir = new THREE.Vector3();
            if(keys['w']) dir.z -= 1;
            if(keys['s']) dir.z += 1;
            if(keys['a']) dir.x -= 1;
            if(keys['d']) dir.x += 1;

            dir.applyEuler(new THREE.Euler(0, player.rotation.y, 0)).normalize().multiplyScalar(speed);

            // Collision Prediction
            const nextPos = player.position.clone().add(new THREE.Vector3(dir.x, 0, dir.z));
            let collided = false;
            
            for(let p of pillars) {
                const dx = nextPos.x - p.position.x;
                const dz = nextPos.z - p.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if(dist < p.userData.radius + 0.5 && player.position.y < p.userData.height) {
                    collided = true; break;
                }
            }
            
            if(!collided) {
                player.position.x += dir.x;
                player.position.z += dir.z;
            }

            // Gravity
            playerVelocityY -= CONFIG.gravity;
            player.position.y += playerVelocityY;

            canJump = false;
            
            // Floor Collision
            if(player.position.y < CONFIG.playerHeight) {
                player.position.y = CONFIG.playerHeight;
                if(playerVelocityY < -0.2 && sounds.landGrass) sounds.landGrass.play();
                playerVelocityY = 0;
                canJump = true;
            }

            // Pillar Top Collision
            for(let p of pillars) {
                const dx = player.position.x - p.position.x;
                const dz = player.position.z - p.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if(dist < p.userData.radius && player.position.y < p.userData.height + CONFIG.playerHeight && player.position.y > p.userData.height) {
                    player.position.y = p.userData.height + CONFIG.playerHeight;
                    if(playerVelocityY < -0.2 && sounds.landMetal) sounds.landMetal.play();
                    playerVelocityY = 0;
                    canJump = true;
                }
            }

            if(player.position.y < -50) player.position.set(0, 10, 0);
        }

        function animate() {
            if(isGameOver) return;
            requestAnimationFrame(animate);

            updatePlayerPhysics();

            // Tank Logic
            if(isInTank) {
                if(keys['w']) tank.translateZ(0.2);
                if(keys['s']) tank.translateZ(-0.2);
                if(keys['a']) tank.rotation.y += 0.02;
                if(keys['d']) tank.rotation.y -= 0.02;
                
                const camOffset = new THREE.Vector3(0, 8, -12);
                camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), tank.rotation.y);
                camera.position.copy(tank.position).add(camOffset);
                camera.lookAt(tank.position);
                ui.prompt.style.display = 'none';
            } else {
                ui.prompt.style.display = player.position.distanceTo(tank.position) < 8 ? 'block' : 'none';
            }

            // Gun Animation
            if(isRecoiling) {
                recoilTime += 0.2;
                gun.position.z = -0.8 + Math.sin(recoilTime) * 0.2;
                if(recoilTime > Math.PI) { isRecoiling = false; gun.position.z = -0.8; }
            }

            // Enemy Logic
            enemies.forEach(e => {
                const target = isInTank ? tank.position : player.position;
                e.lookAt(target.x, e.position.y, target.z);
                
                if(e.position.distanceTo(target) > 8) {
                    e.translateZ(0.05);
                }

                e.userData.shootTimer -= 0.016;
                if(e.userData.shootTimer <= 0) {
                    e.userData.shootTimer = 2 + Math.random();
                    if(sounds.enemyShoot && !sounds.enemyShoot.isPlaying) sounds.enemyShoot.play();
                    
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color:0xff0000}));
                    b.position.copy(e.position).add(new THREE.Vector3(0,1.5,0));
                    const dir = new THREE.Vector3().subVectors(target, e.position).normalize();
                    b.velocity = dir.multiplyScalar(0.4);
                    enemyBullets.push(b);
                    scene.add(b);
                }
            });

            // Player Bullets
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.position.add(b.velocity);
                
                let hit = false;
                // Hit Enemy
                enemies.forEach((e, ei) => {
                    if(!hit && b.position.distanceTo(e.position) < (b.isShell ? 4 : 1.5)) {
                        hit = true;
                        scene.remove(b);
                        bullets.splice(i, 1);
                        
                        e.userData.health -= (b.isShell ? 10 : 1);
                        if(e.userData.health <= 0) {
                            // Explosion if shell
                            if(b.isShell) {
                                const exp = new THREE.Mesh(new THREE.SphereGeometry(4), new THREE.MeshBasicMaterial({color: 0xffa500, transparent:true, opacity:0.8}));
                                exp.position.copy(e.position);
                                scene.add(exp);
                                setTimeout(()=>scene.remove(exp), 200);
                            }
                            scene.remove(e);
                            enemies.splice(ei, 1);
                            
                            const drop = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:0x00ff00, map: textures.bullet || null}));
                            drop.position.copy(e.position);
                            drop.name = "ammo";
                            scene.add(drop);
                        }
                    }
                });

                if(!hit && b.position.length() > 300) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // Enemy Bullets
            for(let i=enemyBullets.length-1; i>=0; i--) {
                const b = enemyBullets[i];
                b.position.add(b.velocity);
                
                if(!isInTank && b.position.distanceTo(player.position) < 1.0) {
                    health -= 10;
                    ui.health.textContent = "Health: " + health;
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                    if(health <= 0) {
                        isGameOver = true;
                        ui.gameOver.style.display = 'flex';
                        document.exitPointerLock();
                    }
                } else if(b.position.length() > 300) {
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                }
            }

            // Pickups
            scene.children.forEach(c => {
                if(c.name === "ammo" && player.position.distanceTo(c.position) < 2) {
                    ammo += 10;
                    ui.ammo.textContent = "Ammo: " + ammo;
                    scene.remove(c);
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>