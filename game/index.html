<!DOCTYPE html>
<html>
<head>
    <title>Advanced 3D Web Gun Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ammo-display, #health-display {
            position: absolute;
            left: 10px;
            color: white;
            font-size: 24px;
            font-family: sans-serif;
            text-shadow: 2px 2px 4px #000000;
        }
        #ammo-display { bottom: 10px; }
        #health-display { bottom: 40px; }
        #prompt-display {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-family: sans-serif;
            text-shadow: 2px 2px 4px #000000;
            display: none;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            color: red;
            font-size: 80px;
            font-family: sans-serif;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
        }
        #game-over small {
            font-size: 24px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="ammo-display">Ammo: 30</div>
    <div id="health-display">Health: 100</div>
    <div id="prompt-display">Press 'E' to enter Tank</div>
    <div id="game-over">
        GAME OVER
        <small>Refresh to restart</small>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const OBJLoader_URL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js';

        let scene, camera, renderer, player, gun, tank, tankTurret, ground;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let tankShells = [];
        let pillars = [];
        let collidableObjects = [];
        let ammo = 30;
        let playerHealth = 100;

        const ui = {
            ammo: document.getElementById('ammo-display'),
            health: document.getElementById('health-display'),
            prompt: document.getElementById('prompt-display'),
            gameOver: document.getElementById('game-over'),
        };

        const keys = {};
        let isInTank = false;
        let enemyModel = null;
        let textures = {};
        let sounds = {};
        let listener;
        let isGameOver = false;
        const clock = new THREE.Clock();

        // Player physics
        const playerVelocity = new THREE.Vector3();
        const gravity = -0.018;
        let onGround = false;
        const playerHeight = 1.8;
        const playerRaycaster = new THREE.Raycaster();

        // Gun animation
        let isRecoiling = false;
        let recoilTimer = 0;

        const script = document.createElement('script');
        script.src = OBJLoader_URL;
        document.head.appendChild(script);
        script.onload = () => loadAssets();

        function loadAssets() {
            const loadingManager = new THREE.LoadingManager(() => {
                init();
                animate();
            });
            const textureLoader = new THREE.TextureLoader(loadingManager);
            const objLoader = new THREE.OBJLoader(loadingManager);
            const audioLoader = new THREE.AudioLoader(loadingManager);
            
            listener = new THREE.AudioListener();

            textures.grass = textureLoader.load('assets/grass.png');
            textures.brown = textureLoader.load('assets/brown.png');
            textures.bullet = textureLoader.load('assets/bullet.png');
            textures.gun = textureLoader.load('assets/gun.png');
            textures.tank = textureLoader.load('assets/tank.png');
            textures.enemy = textureLoader.load('assets/enemy.png');
            textures.sky = textureLoader.load('assets/sky.png');

            objLoader.load('assets/enemy.obj', (obj) => {
                const enemyMaterial = new THREE.MeshStandardMaterial({ map: textures.enemy });
                obj.traverse((child) => {
                    if (child.isMesh) {
                        child.material = enemyMaterial;
                        child.castShadow = true;
                    }
                });
                obj.scale.set(0.8, 0.8, 0.8);
                enemyModel = obj;
            });
            
            const soundPaths = ['gun.mp3', 'enemygun.mp3', 'jump.mp3', 'fallinggrass.mp3', 'fallingonmetal.mp3'];
            soundPaths.forEach(path => {
                const key = path.split('.')[0];
                audioLoader.load(`assets/${path}`, (buffer) => {
                    sounds[key] = new THREE.Audio(listener).setBuffer(buffer);
                });
            });
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.add(listener);

            const skyGeometry = new THREE.SphereGeometry(500, 60, 40);
            skyGeometry.scale(-1, 1, 1);
            const skyMaterial = new THREE.MeshBasicMaterial({ map: textures.sky });
            scene.add(new THREE.Mesh(skyGeometry, skyMaterial));

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            textures.grass.wrapS = THREE.RepeatWrapping;
            textures.grass.wrapT = THREE.RepeatWrapping;
            textures.grass.repeat.set(32, 32);
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ map: textures.grass });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "grass";
            scene.add(ground);
            collidableObjects.push(ground);

            for (let i = 0; i < 20; i++) {
                const pillarHeight = Math.random() * 6 + 3;
                const pillarGeometry = new THREE.CylinderGeometry(1.2, 1.2, pillarHeight, 16);
                const pillarMaterial = new THREE.MeshStandardMaterial({ map: textures.brown });
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(Math.random() * 80 - 40, pillarHeight / 2, Math.random() * 80 - 40);
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                pillar.name = "pillar";
                scene.add(pillar);
                pillars.push(pillar);
                collidableObjects.push(pillar);
            }

            player = new THREE.Object3D();
            player.position.set(0, playerHeight, 5);
            scene.add(player);
            camera.position.set(0, 0, 0); // Camera is at player's "eye" level
            player.add(camera);

            const gunGeometry = new THREE.BoxGeometry(0.1, 0.2, 1);
            const gunMaterial = new THREE.MeshStandardMaterial({ map: textures.gun });
            gun = new THREE.Mesh(gunGeometry, gunMaterial);
            gun.position.set(0.3, -0.3, -0.5); // Lowered gun slightly
            camera.add(gun);

            const tankMaterial = new THREE.MeshStandardMaterial({ map: textures.tank });
            const tankBody = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 6), tankMaterial);
            tankBody.castShadow = true;
            tankTurret = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), tankMaterial);
            tankTurret.position.y = 2;
            tankTurret.castShadow = true;
            tank = new THREE.Object3D();
            tank.add(tankBody);
            tank.add(tankTurret);
            tank.position.set(20, 1.25, -20);
            scene.add(tank);

            for (let i = 0; i < 10; i++) {
                let enemy;
                if (enemyModel) {
                    enemy = enemyModel.clone();
                } else {
                    const fallbackGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                    enemy = new THREE.Mesh(fallbackGeo, fallbackMat);
                }
                enemy.position.set(Math.random() * 80 - 40, 1, Math.random() * 80 - 40);
                enemy.shootCooldown = Math.random() * 2 + 1;
                enemies.push(enemy);
                scene.add(enemy);
            }

            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.body.addEventListener('click', () => document.body.requestPointerLock());
        }

        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            if (event.key.toLowerCase() === 'e') toggleTankMode();
            if (event.code === 'Space' && onGround) {
                playerVelocity.y = 0.28;
                onGround = false;
                if(sounds.jump?.isPlaying === false) sounds.jump.play();
            }
        }
        
        function toggleTankMode() {
            const distanceToTank = player.position.distanceTo(tank.position);
            if (!isInTank && distanceToTank < 6) {
                isInTank = true;
                gun.visible = false;
                player.visible = false;
            } else if (isInTank) {
                isInTank = false;
                gun.visible = true;
                player.visible = true;
                // Place player behind the tank
                const exitOffset = new THREE.Vector3(0, playerHeight, 6);
                exitOffset.applyMatrix4(tank.matrixWorld);
                player.position.copy(exitOffset);
            }
        }

        function onMouseMove(event) {
             if (document.pointerLockElement !== document.body || isGameOver) return;
             if (isInTank) {
                tank.rotation.y -= event.movementX * 0.002;
             } else {
                player.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
             }
        }

        function onMouseDown() {
            if (document.pointerLockElement !== document.body || isGameOver) return;
            shoot();
        }
        
        function shoot() {
            if (isInTank) { /* ... */ } 
            else if (ammo > 0 && !isRecoiling) {
                ammo--;
                ui.ammo.textContent = `Ammo: ${ammo}`;
                isRecoiling = true;
                if(sounds.gun?.isPlaying === false) sounds.gun.play();
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshStandardMaterial({ map: textures.bullet }));
                camera.getWorldDirection(bullet.velocity).multiplyScalar(50);
                bullet.position.copy(player.position).add(bullet.velocity.clone().normalize());
                bullets.push(bullet);
                scene.add(bullet);
            }
        }
        
        function updatePlayer(delta) {
            if (isInTank) return;
            
            // --- MOVEMENT ---
            const speed = (keys['shift'] ? 0.15 : 0.08);
            const moveDirection = new THREE.Vector3();
            if (keys['w']) moveDirection.z -= 1;
            if (keys['s']) moveDirection.z += 1;
            if (keys['a']) moveDirection.x -= 1;
            if (keys['d']) moveDirection.x += 1;
            moveDirection.normalize().applyEuler(player.rotation).multiplyScalar(speed);
            
            const prevPosition = player.position.clone();
            player.position.add(moveDirection);

            // --- HORIZONTAL COLLISION ---
            const playerBox = new THREE.Box3().setFromCenterAndSize(player.position, new THREE.Vector3(0.8, playerHeight, 0.8));
            pillars.forEach(pillar => {
                const pillarBox = new THREE.Box3().setFromObject(pillar);
                if (playerBox.intersectsBox(pillarBox)) {
                     player.position.copy(prevPosition);
                }
            });

            // --- VERTICAL PHYSICS (GRAVITY & JUMPING) ---
            playerVelocity.y += gravity * delta * 60;
            player.position.y += playerVelocity.y;
            
            playerRaycaster.set(player.position, new THREE.Vector3(0, -1, 0));
            const intersections = playerRaycaster.intersectObjects(collidableObjects);
            const isOnObject = intersections.length > 0 && intersections[0].distance < playerHeight;

            if (isOnObject) {
                const groundObject = intersections[0].object;
                if (playerVelocity.y <= 0) { // Only correct position if falling or on ground
                    if (!onGround) { // Just landed
                         if(groundObject.name === "grass" && sounds.fallinggrass?.isPlaying === false) sounds.fallinggrass.play();
                         if(groundObject.name === "pillar" && sounds.fallingonmetal?.isPlaying === false) sounds.fallingonmetal.play();
                    }
                    onGround = true;
                    player.position.y = intersections[0].point.y + playerHeight;
                    playerVelocity.y = 0;
                }
            } else {
                onGround = false;
            }
             if (player.position.y < -20) { // Fell off world
                 player.position.set(0, playerHeight, 5);
             }
        }
        
        function updateGunAnimation(delta) {
            if(isRecoiling) {
                recoilTimer += delta;
                const recoilDuration = 0.2;
                const peak = -0.8;
                const rest = -0.5;
                if(recoilTimer < recoilDuration / 2) {
                    gun.position.z = THREE.MathUtils.lerp(rest, peak, recoilTimer / (recoilDuration / 2));
                } else {
                    gun.position.z = THREE.MathUtils.lerp(peak, rest, (recoilTimer - recoilDuration / 2) / (recoilDuration / 2));
                }
                if(recoilTimer >= recoilDuration) {
                    isRecoiling = false;
                    recoilTimer = 0;
                    gun.position.z = rest;
                }
            }
        }

        function updateEnemies(delta) {
             enemies.forEach(enemy => {
                const target = isInTank ? tank.position : player.position;
                enemy.lookAt(target);
                
                enemy.shootCooldown -= delta;
                if(enemy.shootCooldown <= 0) {
                     if(sounds.enemygun?.isPlaying === false) sounds.enemygun.setVolume(0.4).play();
                     const enemyBullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color: 0xff4444}));
                     const direction = new THREE.Vector3().subVectors(target, enemy.position).normalize();
                     enemyBullet.position.copy(enemy.position).add(new THREE.Vector3(0,1,0)).add(direction);
                     enemyBullet.velocity = direction.multiplyScalar(25);
                     enemyBullets.push(enemyBullet);
                     scene.add(enemyBullet);
                     enemy.shootCooldown = Math.random() * 1 + 1; // 1-2s cooldown
                }
            });
        }

        function animate() {
            if (isGameOver) return;
            const delta = clock.getDelta();
            requestAnimationFrame(animate);

            document.removeEventListener('keydown', onKeyDown); // Prevent duplicate listeners
            document.addEventListener('keydown', onKeyDown);

            updatePlayer(delta);
            updateGunAnimation(delta);
            updateEnemies(delta);

            if (isInTank) {
                if (keys['w']) tank.translateZ(-0.15);
                if (keys['s']) tank.translateZ(0.15);
                if (keys['a']) tank.rotation.y += 0.02;
                if (keys['d']) tank.rotation.y -= 0.02;
                const offset = new THREE.Vector3(0, 6, 12);
                camera.position.copy(tank.position).add(offset.applyMatrix4(new THREE.Matrix4().makeRotationY(tank.rotation.y)));
                camera.lookAt(tank.position);
                ui.prompt.style.display = 'none';
            } else {
                const distanceToTank = player.position.distanceTo(tank.position);
                ui.prompt.style.display = distanceToTank < 6 ? 'block' : 'none';
            }
            
            // Update bullets
            bullets.forEach((b, i) => {
                b.position.add(b.velocity.clone().multiplyScalar(delta));
                if (b.position.distanceTo(player.position) > 100) { scene.remove(b); bullets.splice(i, 1); }
                enemies.forEach((e, ei) => {
                    if (b.position.distanceTo(e.position) < 1.5) {
                        scene.remove(e); enemies.splice(ei, 1);
                        scene.remove(b); bullets.splice(i, 1);
                        const ammoDrop = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ map: textures.bullet }));
                        ammoDrop.name = "ammo";
                        ammoDrop.position.copy(e.position); scene.add(ammoDrop);
                    }
                });
            });

            enemyBullets.forEach((b, i) => {
                b.position.add(b.velocity.clone().multiplyScalar(delta));
                if(!isInTank && b.position.distanceTo(player.position) < 1) {
                    playerHealth = Math.max(0, playerHealth - 10);
                    ui.health.textContent = `Health: ${playerHealth}`;
                    if(playerHealth <= 0) {
                        isGameOver = true;
                        ui.gameOver.style.display = 'flex';
                        document.exitPointerLock();
                    }
                    scene.remove(b); enemyBullets.splice(i, 1);
                } else if (b.position.length() > 200) { scene.remove(b); enemyBullets.splice(i, 1); }
            });
            
            if (!isInTank) {
                 scene.children.forEach((obj) => {
                    if (obj.name === "ammo" && player.position.distanceTo(obj.position) < 1.5) {
                        ammo += 10; ui.ammo.textContent = `Ammo: ${ammo}`; scene.remove(obj);
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>